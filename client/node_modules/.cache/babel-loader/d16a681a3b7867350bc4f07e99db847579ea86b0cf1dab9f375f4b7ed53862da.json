{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileTypeValidator = void 0;\nconst file_validator_interface_1 = require(\"./file-validator.interface\");\nconst load_esm_1 = require(\"load-esm\");\n/**\n * Defines the built-in FileTypeValidator. It validates incoming files by examining\n * their magic numbers using the file-type package, providing more reliable file type validation\n * than just checking the mimetype string.\n *\n * @see [File Validators](https://docs.nestjs.com/techniques/file-upload#validators)\n *\n * @publicApi\n */\nclass FileTypeValidator extends file_validator_interface_1.FileValidator {\n  buildErrorMessage(file) {\n    const expected = this.validationOptions.fileType;\n    if (file?.mimetype) {\n      const baseMessage = `Validation failed (current file type is ${file.mimetype}, expected type is ${expected})`;\n      /**\n       * If fallbackToMimetype is enabled, this means the validator failed to detect the file type\n       * via magic number inspection (e.g. due to an unknown or too short buffer),\n       * and instead used the mimetype string provided by the client as a fallback.\n       *\n       * This message clarifies that fallback logic was used, in case users rely on file signatures.\n       */\n      if (this.validationOptions.fallbackToMimetype) {\n        return `${baseMessage} - magic number detection failed, used mimetype fallback`;\n      }\n      return baseMessage;\n    }\n    return `Validation failed (expected type is ${expected})`;\n  }\n  async isValid(file) {\n    if (!this.validationOptions) {\n      return true;\n    }\n    const isFileValid = !!file && 'mimetype' in file;\n    // Skip magic number validation if set\n    if (this.validationOptions.skipMagicNumbersValidation) {\n      return isFileValid && !!file.mimetype.match(this.validationOptions.fileType);\n    }\n    if (!isFileValid || !file.buffer) return false;\n    try {\n      const {\n        fileTypeFromBuffer\n      } = await (0, load_esm_1.loadEsm)('file-type');\n      const fileType = await fileTypeFromBuffer(file.buffer);\n      if (fileType) {\n        // Match detected mime type against allowed type\n        return !!fileType.mime.match(this.validationOptions.fileType);\n      }\n      /**\n       * Fallback logic: If file-type cannot detect magic number (e.g. file too small),\n       * Optionally fall back to mimetype string for compatibility.\n       * This is useful for plain text, CSVs, or files without recognizable signatures.\n       */\n      if (this.validationOptions.fallbackToMimetype) {\n        return !!file.mimetype.match(this.validationOptions.fileType);\n      }\n      return false;\n    } catch {\n      return false;\n    }\n  }\n}\nexports.FileTypeValidator = FileTypeValidator;","map":{"version":3,"names":["Object","defineProperty","exports","value","FileTypeValidator","file_validator_interface_1","require","load_esm_1","FileValidator","buildErrorMessage","file","expected","validationOptions","fileType","mimetype","baseMessage","fallbackToMimetype","isValid","isFileValid","skipMagicNumbersValidation","match","buffer","fileTypeFromBuffer","loadEsm","mime"],"sources":["C:/Users/Fran/Documents/OlavarraFps/clase1/AFIPNest/proyecto-nombre/node_modules/@nestjs/common/pipes/file/file-type.validator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileTypeValidator = void 0;\nconst file_validator_interface_1 = require(\"./file-validator.interface\");\nconst load_esm_1 = require(\"load-esm\");\n/**\n * Defines the built-in FileTypeValidator. It validates incoming files by examining\n * their magic numbers using the file-type package, providing more reliable file type validation\n * than just checking the mimetype string.\n *\n * @see [File Validators](https://docs.nestjs.com/techniques/file-upload#validators)\n *\n * @publicApi\n */\nclass FileTypeValidator extends file_validator_interface_1.FileValidator {\n    buildErrorMessage(file) {\n        const expected = this.validationOptions.fileType;\n        if (file?.mimetype) {\n            const baseMessage = `Validation failed (current file type is ${file.mimetype}, expected type is ${expected})`;\n            /**\n             * If fallbackToMimetype is enabled, this means the validator failed to detect the file type\n             * via magic number inspection (e.g. due to an unknown or too short buffer),\n             * and instead used the mimetype string provided by the client as a fallback.\n             *\n             * This message clarifies that fallback logic was used, in case users rely on file signatures.\n             */\n            if (this.validationOptions.fallbackToMimetype) {\n                return `${baseMessage} - magic number detection failed, used mimetype fallback`;\n            }\n            return baseMessage;\n        }\n        return `Validation failed (expected type is ${expected})`;\n    }\n    async isValid(file) {\n        if (!this.validationOptions) {\n            return true;\n        }\n        const isFileValid = !!file && 'mimetype' in file;\n        // Skip magic number validation if set\n        if (this.validationOptions.skipMagicNumbersValidation) {\n            return (isFileValid && !!file.mimetype.match(this.validationOptions.fileType));\n        }\n        if (!isFileValid || !file.buffer)\n            return false;\n        try {\n            const { fileTypeFromBuffer } = await (0, load_esm_1.loadEsm)('file-type');\n            const fileType = await fileTypeFromBuffer(file.buffer);\n            if (fileType) {\n                // Match detected mime type against allowed type\n                return !!fileType.mime.match(this.validationOptions.fileType);\n            }\n            /**\n             * Fallback logic: If file-type cannot detect magic number (e.g. file too small),\n             * Optionally fall back to mimetype string for compatibility.\n             * This is useful for plain text, CSVs, or files without recognizable signatures.\n             */\n            if (this.validationOptions.fallbackToMimetype) {\n                return !!file.mimetype.match(this.validationOptions.fileType);\n            }\n            return false;\n        }\n        catch {\n            return false;\n        }\n    }\n}\nexports.FileTypeValidator = FileTypeValidator;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,iBAAiB,GAAG,KAAK,CAAC;AAClC,MAAMC,0BAA0B,GAAGC,OAAO,CAAC,4BAA4B,CAAC;AACxE,MAAMC,UAAU,GAAGD,OAAO,CAAC,UAAU,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,iBAAiB,SAASC,0BAA0B,CAACG,aAAa,CAAC;EACrEC,iBAAiBA,CAACC,IAAI,EAAE;IACpB,MAAMC,QAAQ,GAAG,IAAI,CAACC,iBAAiB,CAACC,QAAQ;IAChD,IAAIH,IAAI,EAAEI,QAAQ,EAAE;MAChB,MAAMC,WAAW,GAAG,2CAA2CL,IAAI,CAACI,QAAQ,sBAAsBH,QAAQ,GAAG;MAC7G;AACZ;AACA;AACA;AACA;AACA;AACA;MACY,IAAI,IAAI,CAACC,iBAAiB,CAACI,kBAAkB,EAAE;QAC3C,OAAO,GAAGD,WAAW,0DAA0D;MACnF;MACA,OAAOA,WAAW;IACtB;IACA,OAAO,uCAAuCJ,QAAQ,GAAG;EAC7D;EACA,MAAMM,OAAOA,CAACP,IAAI,EAAE;IAChB,IAAI,CAAC,IAAI,CAACE,iBAAiB,EAAE;MACzB,OAAO,IAAI;IACf;IACA,MAAMM,WAAW,GAAG,CAAC,CAACR,IAAI,IAAI,UAAU,IAAIA,IAAI;IAChD;IACA,IAAI,IAAI,CAACE,iBAAiB,CAACO,0BAA0B,EAAE;MACnD,OAAQD,WAAW,IAAI,CAAC,CAACR,IAAI,CAACI,QAAQ,CAACM,KAAK,CAAC,IAAI,CAACR,iBAAiB,CAACC,QAAQ,CAAC;IACjF;IACA,IAAI,CAACK,WAAW,IAAI,CAACR,IAAI,CAACW,MAAM,EAC5B,OAAO,KAAK;IAChB,IAAI;MACA,MAAM;QAAEC;MAAmB,CAAC,GAAG,MAAM,CAAC,CAAC,EAAEf,UAAU,CAACgB,OAAO,EAAE,WAAW,CAAC;MACzE,MAAMV,QAAQ,GAAG,MAAMS,kBAAkB,CAACZ,IAAI,CAACW,MAAM,CAAC;MACtD,IAAIR,QAAQ,EAAE;QACV;QACA,OAAO,CAAC,CAACA,QAAQ,CAACW,IAAI,CAACJ,KAAK,CAAC,IAAI,CAACR,iBAAiB,CAACC,QAAQ,CAAC;MACjE;MACA;AACZ;AACA;AACA;AACA;MACY,IAAI,IAAI,CAACD,iBAAiB,CAACI,kBAAkB,EAAE;QAC3C,OAAO,CAAC,CAACN,IAAI,CAACI,QAAQ,CAACM,KAAK,CAAC,IAAI,CAACR,iBAAiB,CAACC,QAAQ,CAAC;MACjE;MACA,OAAO,KAAK;IAChB,CAAC,CACD,MAAM;MACF,OAAO,KAAK;IAChB;EACJ;AACJ;AACAX,OAAO,CAACE,iBAAiB,GAAGA,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}